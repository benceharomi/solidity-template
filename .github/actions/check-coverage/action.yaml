name: Check Coverage
description: >-
  Checks test coverage against a minimum threshold and posts a report as a PR comment.
  Requires `pull-requests: write` permission.

inputs:
  lcov_file:
    description: Path to the lcov.info file.
    default: lcov.info

  minimum-coverage:
    description: Minimum coverage threshold percentage.
    default: 90.00

  github-token:
    description: GitHub token for API access.
    required: true

runs:
  using: composite
  steps:
    - name: Run coverage check
      shell: bash
      env:
        GH_TOKEN: ${{ inputs.github-token }}
        GITHUB_REPOSITORY: ${{ github.repository }}
      run: |
        set -euo pipefail

        echo "üîç Debug: Processing coverage file \"${{ inputs.lcov_file }}\""
        echo "üîç Debug: Minimum coverage threshold: ${{ inputs.minimum-coverage }}%"
        echo "üîç Debug: GitHub event: $GITHUB_EVENT_NAME"

        if [ ! -f "${{ inputs.lcov_file }}" ]; then
          echo "‚ùå Error: Coverage file not found at \"${{ inputs.lcov_file }}\""
          exit 1
        fi
        if ! [[ "${{ inputs.minimum-coverage }}" =~ ^[0-9]+(\.[0-9]+)?$ ]]; then
          echo "‚ùå Error: Invalid minimum coverage value '${{ inputs.minimum-coverage }}'. Must be a number."
          exit 1
        fi
        if ! awk -v val="${{ inputs.minimum-coverage }}" 'BEGIN { exit !(val >= 0 && val <= 100) }'; then
          echo "‚ùå Error: Minimum coverage must be between 0 and 100, got: ${{ inputs.minimum-coverage }}"
          exit 1
        fi

        if ! command -v jq &> /dev/null; then
          echo "‚ùå Error: 'jq' is required but not installed. Please add it to your workflow."
          exit 1
        fi
        if ! command -v gh &> /dev/null; then
          echo "‚ùå Error: GitHub CLI 'gh' is required but not installed. Please add it to your workflow."
          exit 1
        fi

        TOTAL_LINES=$(awk -F: '/^LF:/ {s+=$2} END {print s+0}' "${{ inputs.lcov_file }}")
        HIT_LINES=$(awk -F: '/^LH:/ {s+=$2} END {print s+0}' "${{ inputs.lcov_file }}")

        if [ "$TOTAL_LINES" -eq 0 ]; then
          echo "‚ùå Error: No test coverage data found in \"${{ inputs.lcov_file }}\"."
          echo "   This usually means either:"
          echo "   - No tests were executed"
          echo "   - The coverage file is empty"
          echo "   - The coverage tool didn't generate line coverage information"
          exit 1
        fi

        LINE_COVERAGE=$(awk "BEGIN {printf \"%.2f\", ($HIT_LINES / $TOTAL_LINES) * 100}")
        echo "Line coverage: $LINE_COVERAGE% ($HIT_LINES / $TOTAL_LINES lines)"
        PASSED=$(awk -v cov="$LINE_COVERAGE" -v min="${{ inputs.minimum-coverage }}" 'BEGIN { print (cov >= min) }')

        if [ "$PASSED" = "1" ]; then
          STATUS_ICON="‚úÖ"; STATUS_MESSAGE="Above threshold"
          echo "‚úÖ Coverage check passed ($LINE_COVERAGE% >= ${{ inputs.minimum-coverage }}%)"
        else
          STATUS_ICON="‚ùå"; STATUS_MESSAGE="Below threshold"
          echo "‚ùå Coverage too low ($LINE_COVERAGE% < ${{ inputs.minimum-coverage }}%)"
        fi

        # Generate detailed coverage summary table
        echo "üìä Generating detailed coverage summary..."

        # Create a temporary file to store the coverage data
        COVERAGE_TEMP=$(mktemp)

        # Parse LCOV file and extract coverage data per file
        awk '
        /^SF:/ {
          file = substr($0, 4)
          next
        }
        /^LF:/ {
          lines_found = $2
          next
        }
        /^LH:/ {
          lines_hit = $2
          next
        }
        /^FNF:/ {
          functions_found = $2
          next
        }
        /^FNH:/ {
          functions_hit = $2
          next
        }
        /^BRF:/ {
          branches_found = $2
          next
        }
        /^BRH:/ {
          branches_hit = $2
          next
        }
        /^end_of_record/ {
          if (file != "") {
            # Calculate percentages with division by zero protection
            lines_pct = (lines_found > 0) ? (lines_hit / lines_found) * 100 : 0
            functions_pct = (functions_found > 0) ? (functions_hit / functions_found) * 100 : 0
            branches_pct = (branches_found > 0) ? (branches_hit / branches_found) * 100 : 0

            # Use statements as lines for now (LCOV does not have separate statement coverage)
            statements_pct = lines_pct

            printf "%s|%.2f|%d|%d|%.2f|%d|%d|%.2f|%d|%d|%.2f|%d|%d\n",
              file, lines_pct, lines_hit, lines_found,
              statements_pct, lines_hit, lines_found,
              branches_pct, branches_hit, branches_found,
              functions_pct, functions_hit, functions_found

            # Reset variables
            file = ""
            lines_found = lines_hit = functions_found = functions_hit = branches_found = branches_hit = 0
          }
        }
        ' "${{ inputs.lcov_file }}" > "$COVERAGE_TEMP"

        # Generate the table
        COVERAGE_TABLE=""
        if [ -s "$COVERAGE_TEMP" ]; then
          COVERAGE_TABLE="\`\`\`\n‚ï≠-----------------+---------------+---------------+---------------+---------------‚ïÆ\n"
          COVERAGE_TABLE+="| File            | % Lines       | % Statements  | % Branches    | % Funcs       |\n"
          COVERAGE_TABLE+="+=================================================================================+\n"

          # Process each file
          while IFS='|' read -r file lines_pct lines_hit lines_found statements_pct stmt_hit stmt_found branches_pct branches_hit branches_found functions_pct functions_hit functions_found; do
            # Extract just the filename without path
            filename=$(basename "$file")

            # Format the percentages and counts
            lines_str=$(printf "%.2f%% (%d/%d)" "$lines_pct" "$lines_hit" "$lines_found")
            statements_str=$(printf "%.2f%% (%d/%d)" "$statements_pct" "$stmt_hit" "$stmt_found")
            branches_str=$(printf "%.2f%% (%d/%d)" "$branches_pct" "$branches_hit" "$branches_found")
            functions_str=$(printf "%.2f%% (%d/%d)" "$functions_pct" "$functions_hit" "$functions_found")

            # Pad filename to 15 characters
            filename_padded=$(printf "%-15s" "$filename")

            COVERAGE_TABLE+="| $filename_padded | $(printf "%-13s" "$lines_str") | $(printf "%-13s" "$statements_str") | $(printf "%-13s" "$branches_str") | $(printf "%-13s" "$functions_str") |\n"
            COVERAGE_TABLE+="|-----------------+---------------+---------------+---------------+---------------|\n"
          done < "$COVERAGE_TEMP"

          # Add total row
          total_lines_pct=$(awk "BEGIN {printf \"%.2f\", ($HIT_LINES / $TOTAL_LINES) * 100}")
          total_lines_str=$(printf "%.2f%% (%d/%d)" "$total_lines_pct" "$HIT_LINES" "$TOTAL_LINES")

          # Calculate totals for other metrics with division by zero protection
          TOTAL_FUNCTIONS_FOUND=$(awk -F: '/^FNF:/ {s+=$2} END {print s+0}' "${{ inputs.lcov_file }}")
          TOTAL_FUNCTIONS_HIT=$(awk -F: '/^FNH:/ {s+=$2} END {print s+0}' "${{ inputs.lcov_file }}")
          TOTAL_BRANCHES_FOUND=$(awk -F: '/^BRF:/ {s+=$2} END {print s+0}' "${{ inputs.lcov_file }}")
          TOTAL_BRANCHES_HIT=$(awk -F: '/^BRH:/ {s+=$2} END {print s+0}' "${{ inputs.lcov_file }}")

          # Safe percentage calculations
          if [ "$TOTAL_FUNCTIONS_FOUND" -gt 0 ]; then
            total_functions_pct=$(awk "BEGIN {printf \"%.2f\", ($TOTAL_FUNCTIONS_HIT / $TOTAL_FUNCTIONS_FOUND) * 100}")
          else
            total_functions_pct=0.00
          fi

          if [ "$TOTAL_BRANCHES_FOUND" -gt 0 ]; then
            total_branches_pct=$(awk "BEGIN {printf \"%.2f\", ($TOTAL_BRANCHES_HIT / $TOTAL_BRANCHES_FOUND) * 100}")
          else
            total_branches_pct=0.00
          fi

          total_statements_str="$total_lines_str"
          total_branches_str=$(printf "%.2f%% (%d/%d)" "$total_branches_pct" "$TOTAL_BRANCHES_HIT" "$TOTAL_BRANCHES_FOUND")
          total_functions_str=$(printf "%.2f%% (%d/%d)" "$total_functions_pct" "$TOTAL_FUNCTIONS_HIT" "$TOTAL_FUNCTIONS_FOUND")

          COVERAGE_TABLE+="| Total           | $(printf "%-13s" "$total_lines_str") | $(printf "%-13s" "$total_statements_str") | $(printf "%-13s" "$total_branches_str") | $(printf "%-13s" "$total_functions_str") |\n"
          COVERAGE_TABLE+="‚ï∞-----------------+---------------+---------------+---------------+---------------‚ïØ\n\`\`\`"
        else
          COVERAGE_TABLE="*No detailed coverage data available*"
        fi

        # Clean up temp file
        rm -f "$COVERAGE_TEMP"

        COMMENT_TAG="<!-- coverage-check-comment -->"
        COMMENT_BODY=$(cat <<-EOF
          ### üìä Coverage Report

          | Metric | Coverage | Required | Status |
          |--------|----------|----------|--------|
          | Lines  | \`$LINE_COVERAGE%\` | \`${{ inputs.minimum-coverage }}%\` | $STATUS_ICON $STATUS_MESSAGE |

          **Details**: $HIT_LINES of $TOTAL_LINES lines covered.

          #### üìã Detailed Coverage Summary

          $COVERAGE_TABLE

          $COMMENT_TAG
        EOF
        )

        if [ "$GITHUB_EVENT_NAME" != "pull_request" ]; then
          echo "‚ö†Ô∏è Not a pull request event. Skipping PR comment."
        else
          PR_NUMBER=$(jq --raw-output .pull_request.number "$GITHUB_EVENT_PATH")
          if [ -z "$PR_NUMBER" ] || [ "$PR_NUMBER" = "null" ]; then
            echo "‚ùå Error: Could not determine PR number from event payload."
            exit 1
          fi

          echo "üîç Searching for existing comment on PR #$PR_NUMBER..."
          COMMENT_ID=$(gh api --paginate "/repos/$GITHUB_REPOSITORY/issues/$PR_NUMBER/comments" | jq --arg tag "$COMMENT_TAG" --raw-output '[.[] | select(.body | contains($tag))] | sort_by(.created_at) | last | .id')

          if [ -n "$COMMENT_ID" ] && [ "$COMMENT_ID" != "null" ]; then
            echo "Found previous comment (ID: $COMMENT_ID). Updating it."
            BODY_JSON=$(jq -R --slurp '{body: .}' <<< "$COMMENT_BODY")
            # Update the comment and redirect the successful JSON output to /dev/null to keep logs clean.
            gh api --method PATCH "/repos/$GITHUB_REPOSITORY/issues/comments/$COMMENT_ID" --input - <<< "$BODY_JSON" > /dev/null
          else
            echo "No previous comment found. Creating a new one."
            gh pr comment "$PR_NUMBER" --body "$COMMENT_BODY"
          fi
        fi

        if [ "$PASSED" != "1" ]; then
          echo "Failing the workflow because test coverage is below the threshold."
          exit 1
        fi

        echo "‚úÖ Coverage check completed successfully."
